{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({\n  x,\n  y\n}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {\n    mode = 'xy',\n    scaleMode,\n    overScaleMode\n  } = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction updateRange(scale, {\n  min,\n  max\n}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {\n    id,\n    axis,\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min,\n    max\n  };\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {\n    min: minLimit = -Infinity,\n    max: maxLimit = Infinity\n  } = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, amount, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = event => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n  if (onZoomStart) {\n    const point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\n  const endPoint = getRelativePosition(endPointEvent, chart);\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  const width = right - left;\n  const height = bottom - top;\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(() => state.dragging = false, 500);\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => state.panning = false, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nvar version = \"2.0.1\";\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {\n    dragStart,\n    dragEnd\n  } = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {\n    left,\n    top,\n    width,\n    height\n  } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = transition => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };","map":{"version":3,"names":["Hammer","each","valueOrDefault","callback","sign","getRelativePosition","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","directionsEnabled","x","y","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","options","point","scaleMode","overScaleMode","scaleEnabled","overScaleEnabled","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","set","removeState","delete","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","Math","getValueForPixel","maxPercent","getLimit","scaleLimits","prop","fallback","limit","original","id","getRange","pixel0","pixel1","v0","v1","updateRange","limits","scaleOpts","minRange","minLimit","Infinity","maxLimit","offset","parse","zoomNumericalScale","delta","zoomRectNumericalScale","from","to","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","zoomRectFunctions","panFunctions","logarithmic","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","doZoomRect","getCenter","ca","chartArea","transition","focalPoint","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","pan","panOptions","onPan","getInitialScaleBounds","scaleBounds","isZoomedOrPanned","originalMin","originalMax","removeHandler","handler","target","removeEventListener","addHandler","oldHandler","addEventListener","mouseMove","dragStart","dragging","dragEnd","keyDown","zoomStart","onZoomStart","onZoomRejected","mouseDown","button","drag","canvas","window","document","computeDragRect","beginPointEvent","endPointEvent","chartWidth","chartHeight","beginPoint","endPoint","zoomX","zoomY","mouseUp","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","getBoundingClientRect","speed","clientX","clientY","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","ownerDocument","removeListeners","createEnabler","recognizer","srcEvent","panning","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","draw","caller","drawTime","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop"],"sources":["D:/Documents/Desktop/Folder nou (2)/Pentalog_Project/stock-app/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n\n  return {x: false, y: false};\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1,\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\n  ));\n\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {id, axis, options: scaleOpts} = scale;\n\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n\n  state.updatedScaleLimits[scale.id] = {min, max};\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction doZoomRect(scale, amount, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\n\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\n  const endPoint = getRelativePosition(endPointEvent, chart);\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"2.0.1\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n  const ctx = chart.ctx;\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}